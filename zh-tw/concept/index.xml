<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基礎概念 on GRAVITY</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/</link><description>Recent content in 基礎概念 on GRAVITY</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><atom:link href="https://brobridgeorg.github.io/gravity-website/zh-tw/concept/index.xml" rel="self" type="application/rss+xml"/><item><title>一對一管線</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/1-on-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/1-on-1/</guid><description>一對ㄧ管線是資料系統架構的起手式，能從單一資料源接收資料，然後將資料推送到指定接收端。實務上，一對多管線能實現資料庫同步對抄、資料遷移、資料快取、主從架構（Master-Slave）和資料庫熱備份備援等機制。
flowchart LR source([源頭資料庫]) -- |推送資料更新| adapter(資料源適配器\nAdapter) subgraph GRAVITY adapter(資料源適配器\nAdapter) -- gravity{{GRAVITY\n資料節點}} gravity{{GRAVITY\n資料節點}} -- transmitterA(資料傳輸器\nTransmitter) end transmitterA(資料傳輸器\nTransmitter) -- |寫入資料| targetA([目標資料庫]) class gravity gravity; classDef gravity fill:#b00,color:#fff,stroke:#800,stroke-width:3px; class adapter adapter; classDef adapter fill:#555,color:#fff,stroke:#fff,stroke-width:3px; class transmitterA transmitter; classDef transmitter fill:#222,color:#fff,stroke:#fff,stroke-width:3px; class source,targetA database; classDef database fill:#eee,color:#555,stroke:#bbb,stroke-width:2px;</description></item><item><title>一對多管線</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/1-on-n/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/1-on-n/</guid><description>一對多管線能從單一資料源接收資料，然後將資料同時傳輸到多個接收端。實務上，一對多管線能實現的資料庫多重複寫（Replication）機制，生成多份資料副本，藉由副本數量的擴展來增加資料庫的併發查詢能力。此外，也可以利用一對多管線實現資料分片（Sharding）機制。
flowchart LR source([源頭資料庫]) -- |推送資料更新| adapter(資料源適配器\nAdapter) subgraph GRAVITY adapter(資料源適配器\nAdapter) -- gravity{{GRAVITY\n資料節點}} gravity{{GRAVITY\n資料節點}} -- transmitterA(資料傳輸器\nTransmitter) gravity{{GRAVITY\n資料節點}} -- transmitterB(資料傳輸器\nTransmitter) end transmitterA(資料傳輸器 A\nTransmitter) -- |寫入副本資料| targetA([目標資料庫 A]) transmitterB(資料傳輸器 B\nTransmitter) -- |寫入副本資料| targetB([目標資料庫 B]) class gravity gravity; classDef gravity fill:#b00,color:#fff,stroke:#800,stroke-width:3px; class adapter adapter; classDef adapter fill:#555,color:#fff,stroke:#fff,stroke-width:3px; class transmitterA,transmitterB transmitter; classDef transmitter fill:#222,color:#fff,stroke:#fff,stroke-width:3px; class source,targetA,targetB database; classDef database fill:#eee,color:#555,stroke:#bbb,stroke-width:2px;</description></item><item><title>多對一管線</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/n-on-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/n-on-1/</guid><description>多對一管線用於收集多個資料源的資料，然後進行聚合、關聯處理。實務上，多對一管線被用於實現合併複寫（Merge Replication）以跨資料庫系統的資料關聯，或是用於改善瞬間巨量寫入時的場景，將分流寫入的資料匯整到指定的落地資料庫。
flowchart LR sourceA([源頭資料庫 A]) -- |推送資料更新| adapterA(資料源適配器 A\nAdapter) sourceB([源頭資料庫 B]) -- |推送資料更新| adapterB(資料源適配器 B\nAdapter) subgraph GRAVITY adapterA -- gravity{{GRAVITY\n資料節點}} adapterB -- gravity{{GRAVITY\n資料節點}} gravity{{GRAVITY\n資料節點}} -- transmitterA(資料傳輸器\nTransmitter) end transmitterA(資料傳輸器\nTransmitter) -- |寫入資料| targetA([目標資料庫]) class gravity gravity; classDef gravity fill:#b00,color:#fff,stroke:#800,stroke-width:3px; class adapterA,adapterB adapter; classDef adapter fill:#555,color:#fff,stroke:#fff,stroke-width:3px; class transmitterA transmitter; classDef transmitter fill:#222,color:#fff,stroke:#fff,stroke-width:3px; class sourceA,sourceB,targetA database; classDef database fill:#eee,color:#555,stroke:#bbb,stroke-width:2px;</description></item><item><title>資料節點對連鏈路</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/datanode-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/datanode-link/</guid><description>資料節點對連鏈路，可以從另一個資料節點訂閱資料，然後等待進一步處理，通常用於跨組織資料授權管理、跨雲資料整合場景。對於資料系統來說，善用資料節點的對連鏈路進行架構設計，可以構成極具彈性的資料供應架構。
flowchart LR source([源頭資料庫]) -- |推送資料更新| adapter(資料源適配器\nAdapter) subgraph GRAVITY A adapter(資料源適配器\nAdapter) -- gravityA{{GRAVITY\n資料節點 A}} end gravityA{{GRAVITY\n資料節點 A}} == Link == gravityB{{GRAVITY\n資料節點 B}} subgraph GRAVITY B gravityB{{GRAVITY\n資料節點 B}} -- transmitterA(資料傳輸器\nTransmitter) end transmitterA(資料傳輸器\nTransmitter) -- |寫入資料| targetA([目標資料庫]) class gravityA,gravityB gravity; classDef gravity fill:#b00,color:#fff,stroke:#800,stroke-width:3px; class adapter adapter; classDef adapter fill:#555,color:#fff,stroke:#fff,stroke-width:3px; class transmitterA transmitter; classDef transmitter fill:#222,color:#fff,stroke:#fff,stroke-width:3px; class source,targetA database; classDef database fill:#eee,color:#555,stroke:#bbb,stroke-width:2px; 多節點對連 藉由資料節點的對連，可把多個管線相互對接，形成更龐大的資料鏈路，把資料供應到更多地方。組合運用 GRAVITY 的各種機制（如：複寫、快取、分片和聚合等），打造一個可以動態彈性擴展的資料系統，即可用軟體定義的方式，自由改造資料系統架構，不再受到既有資料庫系統能力、硬體規模、距離或區域所限制。
flowchart LR sourceA([源頭資料庫 A]) -- |推送資料更新| adapterA(資料源適配器\nAdapter) subgraph 資料代理 adapterA(資料源適配器\nAdapter) -- gravityA{{GRAVITY\n資料節點 A}} end sourceB([源頭資料庫 B]) -- |推送資料更新| adapterB(資料源適配器\nAdapter) sourceC([源頭資料庫 C]) -- |推送資料更新| adapterB(資料源適配器\nAdapter) subgraph 資料聚合 adapterB(資料源適配器\nAdapter) -- gravityD{{GRAVITY\n資料節點 D}} end gravityA{{GRAVITY\n資料節點 A}} == gravityB{{GRAVITY\n資料節點 B}} gravityA{{GRAVITY\n資料節點 A}} == gravityC{{GRAVITY\n資料節點 C}} gravityD{{GRAVITY\n資料節點 D}} == 授權訂閱 == gravityC{{GRAVITY\n資料節點 C}} subgraph 資料複寫同步 gravityB{{GRAVITY\n資料節點 B}} -- transmitterA(資料傳輸器\nTransmitter) end subgraph 資料分片 gravityC{{GRAVITY\n資料節點 C}} -- transmitterB(資料傳輸器\nTransmitter) gravityC{{GRAVITY\n資料節點 C}} -- transmitterC(資料傳輸器\nTransmitter) end transmitterA(資料傳輸器\nTransmitter) -- |寫入資料| targetA([副本資料庫]) transmitterB(資料傳輸器\nTransmitter) -- |寫入分片 A| targetB([分片資料庫 A]) transmitterC(資料傳輸器\nTransmitter) -- |寫入分片 B| gravityE{{GRAVITY\n資料節點 E}} subgraph 資料再分片 gravityE{{GRAVITY\n資料節點 E}} -.</description></item><item><title>事件資料集</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/collection/</guid><description>GRAVITY 的資料節點會在從資料源收集變更事件之後，由內建的資料處理器對事件進行分類聚合工作，最後以「資料集（Collection）」的形式保存，應用可以自由選擇資料集及進行訂閱，接收並取得所需要的資料。
flowchart LR source([資料源\nData Source]) -- eventA(變更事件) source -- eventB(新增事件) source -- eventC(修改事件) source -- eventD(刪除事件) eventA -- gravity((資料處理器\nData Handler)) eventB -- gravity eventC -- gravity eventD -- gravity subgraph GRAVITY 資料節點 gravity -- |分類儲存| collectionA gravity -- |分類儲存| collectionB gravity -- collectionC(更多資料集\n...) end collectionA(資料集 A\nCollection) -- |訂閱資料| targetA([目標資料庫\nTarget]) collectionB(資料集 B\nCollection) -- |訂閱資料| targetA class gravity gravity; classDef gravity fill:#222,color:#fff,stroke:#fff,stroke-width:3px; class eventA,eventB,eventC,eventD event; classDef event fill:#666,color:#fff,stroke:#fff,stroke-width:3px; class collectionA,collectionB,collectionC collection; classDef collection fill:#fffe,color:#B00,stroke:#B00,stroke-width:5px; class source,targetA database; classDef database fill:#eee,color:#555,stroke:#bbb,stroke-width:2px; 資料集的組成 當事件被分類到資料集後，會以「事件歷史紀錄（Event History）」和「資料快照（Snapshot）」兩種形式保存下來。</description></item><item><title>資料欄位對應</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/field-mapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/field-mapping/</guid><description>從資料源收集回來的事件，可以依據應用的需求進行欄位的對應轉換，然後存放到資料集（Collection）之中。利用資料欄位對應機制，可以將不同來源或格式的事件，轉成同樣的格式存放或資料聚合。若是有需要抽取事件中的特定少數欄位資料，也可利用此機制來實現。
flowchart LR subgraph 事件欄位 field_a_name(name) field_a_phone(phone) field_a_address(address) end subgraph 對應轉換後 field_b_fullname(fullname) field_b_addr(addr) end field_a_name(name) -- field_b_fullname(fullname) field_a_phone(phone) field_a_address(address) -- field_b_addr(addr) field_b_fullname -- collectionA(資料集) field_b_addr -- collectionA class field_a_name,field_a_phone,field_a_address field_a; classDef field_a fill:#333,color:#fff,stroke:#fff,stroke-width:3px; class field_b_fullname,field_b_addr field_b; classDef field_b fill:#666,color:#fff,stroke:#fff,stroke-width:3px; class collectionA collection; classDef collection fill:#fffe,color:#B00,stroke:#B00,stroke-width:5px; class targetA,targetB database; classDef database fill:#eee,color:#555,stroke:#bbb,stroke-width:2px;</description></item><item><title>資料分區</title><link>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://brobridgeorg.github.io/gravity-website/zh-tw/concept/partitioning/</guid><description>資料節點內部實現了分區（Partitioning）機制，事件和資料會依據主鍵（Primary Key）被分區處理並存放，如此可以實現平行處理提高處理效率，也能確保事件的發生順序不會在平行處理過程中被打亂。實務上，當我們使用 GRAVITY 實現分片（Sharding）機制時，即是藉由了資料節點內部分區的機制，由多個資料傳輸器（Transmitter）分別訂閱指定分區的資料，然後各自寫入到不同的目標資料庫。</description></item></channel></rss>